---
title: "test_gsusie"
author: "Yixin (Izzy) Zhang"
date: "2024-03-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Prepare ATAC data
## data cleaning/wrangling
```{r}
library(vroom)
library(dplyr)

Sys.setenv("VROOM_CONNECTION_SIZE"=1000000000)

atac_act_file_path <- "./GSE162170/GSE162170_multiome_atac_gene_activities.tsv.gz"

# Read data with vroom, skipping the first row (since we don't have data at [1,1] it woudl crunch the cols)
atac_real_data <- vroom(atac_act_file_path, delim = "\t", col_names = FALSE, col_types = cols(), skip = 1)
```
transpose data, and set genenames as colnamesï¼Œremove gene names in the first row, change data to numeric
```{r}
atac_real_data = data.frame(t(atac_real_data))
```

```{r}
colnames(atac_real_data) <- unlist(atac_real_data[1, ])# assign col names with first row
```

```{r}
atac_real_data <- atac_real_data[-1, ] # remove first row
```

```{r}
# change data to character
atac_real_data[] <- lapply(atac_real_data, function(x) if(is.character(x)) as.numeric(x) else x)
```

get percentage of zeros
```{r}
percentage_zeros <- sapply(atac_real_data, function(column) {
  mean(column == 0) * 100
})
```
plot percentage of zeros
```{r}
hist(percentage_zeros)
```

```{r}
library(dplyr)
# solution for non-unique names error in filtering variables
# Create a function to rename duplicates with a unique suffix
make_unique <- function(names) {
  counts <- ave(seq_along(names), names, FUN = seq_along)
  unique_names <- ifelse(counts == 1, names, paste(names, counts, sep = "_"))
  return(unique_names)
}

# Apply the function to your dataframe's column names
colnames(atac_real_data) <- make_unique(colnames(atac_real_data))

```

Remove cols with missingness over 10% (arbitrary, for computing/imputing sake)
resulting df has 841 variables, which is 841/19836 = 0.04 of the entire ATAC data

```{r}
cols_to_remove <- sapply(atac_real_data, function(column) mean(column == 0) > 0.1)
atac_real_data_0_filtered <- atac_real_data[, !cols_to_remove]
```

```{r}
# save filtered data to local
# write.csv(atac_real_data, "./test_data/rearranged_atac_activity.csv", row.names=FALSE)
# write.csv(atac_real_data_0_filtered, "./test_data/zero_rm_10_atac_activity.csv", row.names=FALSE)
```

```{r}
atac_real_data_0_filtered_10 <- read.csv("./test_data/zero_rm_10_atac_activity.csv", header = TRUE)
```

```{r}
#convert to matrix (for gsusie)
atac_matrix <- as.matrix(atac_real_data_0_filtered_10)
colnames(atac_matrix) <- NULL
```

## Solution(s) to: ATACseq data contains missing (0s) and is lognormal 
Try1. apply log to 0s: gsusie does not work with -Inf values (Too much abnormal subjects detected!)
Try2. listwise deletion & pairwise deletion (does not work: it would remove all the rows/columns)
```{r}
# rows_with_zeros <- apply(atac_matrix, 1, function(x) any(x == 0))
# atac_matrix_0_rm <- atac_matrix[!rows_with_zeros, ]
# atac_log_matrix_0_rm <- log(atac_matrix_0_rm)
```
Try3. Imputation before standardization (taking too long, blackbox impute)
```{r}
# library(hdImpute)
# ## hdImpute: fast random forest
# hdImpute(data.frame(atac_log_matrix_NA_st), batch = 100, seed = 0, save = TRUE)
```

**4. replace 0 with NA --> log --> standardize --> fill in NA with 0 --> gsusie ("Too much abnormal subjects detected!")**
```{r}
atac_matrix_NA <- atac_matrix
atac_matrix_NA[atac_matrix_NA == 0] <- NA #replace 0 with NA
atac_log_matrix_NA <- log(atac_matrix_NA) #apply log transformation
```
standardize
```{r}
atac_log_matrix_NA_st <-apply(atac_matrix_NA, 2, function(x) {
    (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
  })
```
replace na with 0 (since the standardized data have mean = 0) in the standardized data
```{r}
atac_log_matrix_NA_st[is.na(atac_log_matrix_NA_st)] <- 0
```

# prepare RNAseq data
get from ``test_data``
```{r}
rna_7_var <- read.csv('./test_data/rna_7_var.csv')
```

take a look at distribution
```{r}
hist(rna_7_var$SOX2, breaks = 12)
```
apply log1p
```{r}
SOX2RNA <- exp(log1p(rna_7_var$SOX2))
hist(SOX2RNA)
```

```{r}
mean(SOX2RNA)
var(SOX2RNA)
```
overdispersed

```{r}
rna_matrix <- as.matrix(SOX2RNA) # prepare y
```


# apply gsusie 
(30 seconds to run on 841 predictor variables (4% of entire ATAC dataset))
```{r}
library(gsusie)
res_gs2 <- gsusie(cbind(atac_log_matrix_NA_st, 1), rna_matrix, family = "poisson")
```
```{r}
print_gsusie_coefficients(res_gs2)
```

```{r}
print(res_gs2$sets)
gsusie_plot(res_gs2, y = "PIP", include_intercept = FALSE, intercept_index = (ncol(atac_matrix)+1))
gsusie_plot(res_gs2, y = "PIP", include_intercept = TRUE)
```
```{r}
summary(res_gs2)
```

find out the ATAC gene names to those variables with high PIP
```{r}
atac_filtered_colnames <- colnames(atac_real_data_0_filtered_10)
atac_filtered_colnames[as.integer(unlist(res_gs2$sets$cs))]
```

## spearman correlation
get predicted value
```{r}
print_gsusie_coefficients(res_gs2)
```
poisson GLM is given by 
$log(y) = \alpha + \beta_1 x_1 + \beta_2 x_2 + \dots + \beta_p x_p$
```{r}
#get variable indices
library(dplyr)
var_of_choice <- summary(res_gs2)$vars %>%
  filter(variable_prob >= 0.5) %>%
  arrange(cs, desc(variable_prob)) %>%
  group_by(cs) %>%
  slice(1) %>%
  ungroup()

print(var_of_choice)

```
```{r}
X_res_gs2 <- cbind(atac_log_matrix_NA_st, 1)

coef_summary <- var_of_choice %>%
  left_join(print_gsusie_coefficients(res_gs2) %>% select(variable, PostMean, PostSD, CI_lower, CI_upper), by = "variable")

y_pred <- exp(X_res_gs2[, var_of_choice$variable] %*% as.matrix(coef_summary$PostMean))
y_pred_log <- X_res_gs2[, var_of_choice$variable] %*% as.matrix(coef_summary$PostMean)
```

scatterplot
```{r}
plot(x=y_pred, y= rna_matrix,
     xlab='Predicted Values',
     ylab='Actual Values',
     main='Predicted vs. Actual Values')
abline(a=0, b=1)
```

scatterplot(log scale)
```{r}
plot(x=y_pred_log, y= log(rna_matrix),
     xlab='log(Predicted Values)',
     ylab='log(Actual Values)',
     main='Predicted vs. Actual Values (log-scaled)')
abline(a=0, b=1)
```

spearman correlation
```{r}
cor(y_pred, rna_matrix, method = "spearman")
```


```{r}
# get all variables with probability > 0.5, if multiple variables in same credible set, use one variable with largest probability
get_fitted_poisson_values <- function(object, prob_threshod = 0.5) {
  var_of_choice <- summary(object)$vars %>%
    filter(variable_prob >= prob_threshod) %>%
    arrange(cs, desc(variable_prob)) %>%
    group_by(cs) %>%
    slice(1) %>%
    ungroup()
  
  X_res_gs2 <- cbind(atac_log_matrix_NA_st, 1)
  
  coef_summary <- var_of_choice %>%
    left_join(
      print_gsusie_coefficients(object) %>% select(variable, PostMean, PostSD, CI_lower, CI_upper),
      by = "variable"
    )
  
  y_pred <-
    exp(X_res_gs2[, var_of_choice$variable] %*% as.matrix(coef_summary$PostMean))
  y_pred_log <-
    X_res_gs2[, var_of_choice$variable] %*% as.matrix(coef_summary$PostMean)
  return (list(y_pred = y_pred, y_pred_log = y_pred_log))
}
```

```{r}
predicted_vs_actual_scatterplot <-
  function(object) {
    y_pred <- get_fitted_poisson_values(object)$y_pred
    y_pred_log <- get_fitted_poisson_values(object)$y_pred_log
    plot(
      x = y_pred,
      y = rna_matrix,
      xlab = 'Predicted Values',
      ylab = 'Actual Values',
      main = 'Predicted vs. Actual Values'
    )
    abline(a = 0, b = 1)
    
    plot(
      x = y_pred_log,
      y = log(rna_matrix),
      xlab = 'log(Predicted Values)',
      ylab = 'log(Actual Values)',
      main = 'Predicted vs. Actual Values (log-scaled)'
    )
    abline(a = 0, b = 1)
  }
```

```{r}
predicted_vs_actual_scatterplot(res_gs2)
```

```{r}
spearman_correlation_predicted_actual <- function(object){
  y_pred <- get_fitted_poisson_values(object)$y_pred
  cor(y_pred, rna_matrix, method = "spearman")
}
```

```{r}
spearman_correlation_predicted_actual(res_gs2)
```

